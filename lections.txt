***** 1_part(2) *****
1.------------------
TS надстройка над js. В барзуер попадает js
2.------------------
npm i -g typescript ts-node
ts-node - its for starting compale ts to js in terminal
Настройка vscode и prettier расширения
3.------------------
npm i axios
npm init -y
4.------------------
tsc index.ts - скомпилировать в js ( tsc === typescript compiler )
node index.js - запус самого js file
Совмещает две это команды: ts-node index.ts
5.------------------
Намеренно совершили ошибку в деструктуризации response.data
6.------------------
В TS Interface используются для определения структуры объекта
Пример интерфейса: interface Todo {id: number; title: string; completed: boolean; }
Это поможет нам без ошибок деструктуризировать объект
7.------------------
Мы можем перепутать местами аргументы функции или передать не тот тип данных.
И когда передаются параметры функции, то указать к ним их типы:
function(id: number, title: string, completed: boolean){}

***** 2_part(3) *****
2.1.-----------------
Объяснение структуры курса
2.2.-----------------
Тип - задает способ обращения к свойствам и функциям(методам),
которые есть у некоторого значения. Например:
'orange' - это строка. У нее тип String и поэтому мы можем обращаться
к методам и свойствам строк в JS
2.3------------------
Типы делят на 2 группы: {
    Примитивные: {
        string, number, void, symbol, null, boolean и т.д
    },
    Объектные
}
2.4, 2.5-------------
Применение типов

***** 3_part(4) *****
3.1 - 3.5 -----------
Аннотация(указание) типов - это явное указание типа хранимых данных.
let index: number = 1;
Выведение типов - когда TS сам понимает, какой тип хранится в переменной.
Выведение работает только при указании значения в момент инициализации переменной.
let index = 5;
Если нужно указать несколько типов то:
let index: number | string = 5;
3.6------------------
Аннотация использовать когда тип ': any'. Получается когда TS не знает значение какого типа будет возвращаться.
И не может проверить на содержание проверок.

***** 4_part(5) *****
4.1 - 4.2 -----------
К возвращаемому из функции значению можно применить выведение типов.
Но этого делать не стоит, а лучше строго прописывать.
Так же выведение никак не работает для параметров функции.
4.4------------------
void - пустой. Применять когда ничего не возвращается
4.5------------------
Деструктуризация по правилам TS
4.6------------------
Деструктуризация вложенных объектов доставляет мало удовольствия

***** 5_part(6) *****
5.1------------------
Массивы в TS типизарованы. Состоят из одного типа данных, но всегда.
5.2------------------
Не получится добавить значение другого типа в массив.
Когда извлекается значения из массива и присваивается перемнной,
то TS сделает выведение типа.
5.3------------------
Чтобы добавлять разные типы данных в TS, то
нужно написать аннотоацию типов, если массив изначально пустой
или есть данные только одного типа, но в будущем будут и другие:
const itemsMass: (string | number)[] = [];
5.4------------------
В TS есть кортежи. Разобрано дальше.

***** 6_part(7) *****
6.1------------------
Кортеж. Я понял смысл кортежа, но описать не могу. Пример:
cont tuple = ['brown', 13, true];
В Tuple(Кортеж) элементы расположены в строгом порядке.
6.2------------------
Tuple syntax:
const testTuple: [string, boolean, number, date] = ['123', true, 100, new Date()];
Alias for Tuple:
type Alias: [string, number];
const tupleAlias: Alias = ['text', 123]
6.3------------------
Tuple не дают понимание того, что означают элементы массива.
Редко применяются. Объект лучше.

***** 7_part(8) *****
7.1------------------
Создает новый тип, описывая название свойств и типы значений объекта.
Тема очень важная
7.2------------------
Аннотации писать долго и код повторяется.
7.3------------------
7.4------------------
Используй Интефейс
7.5------------------
рефкторинг
7.6------------------
Интефейсы круты тем что их можно повторно использовать
7.7------------------
Входные параметры не соответствующие интерфейсу не попадут в функцию

***** 8_part *****
8.1 - 8.2 -----------
Тупо объяснения классов
8.3------------------
Есть три типа модификаторов.
public - каждый может вызывать.
private - вызов только внутри класса где объявлен.
protected - только внутри класса и внтури его наследников.
8.4------------------
8.5------------------
Если у ребенка нет Constructor, то он вызывает родительский.
Вызывать super() родителя.
8.6------------------

***** 9_part(10) *****
9.1------------------
Введение. npm i parcel
9.2------------------
Нет видео
9.3------------------
Создание класса User
9.4------------------
npm i faker
Могут быть проблемы с импортом ts файлов
9.5------------------
Файлы js не подходят для ts файлов. TS требуются типы.
Решить проблему может "файл определения типов".
@types/{the package name}
Example: npm i @types/faker
9.6------------------
Video file not found in folder.
Скорее всего разбирался функционал faker
9.7------------------
Импортирует класс в index.ts
9.8------------------
9.9------------------
добавили в проект google maps: https://console.cloud.google.com/
9.10-----------------
npm i @types/google.maps
9.11-----------------
video not found. инициализация google maps
9.12-----------------
Обсуждение архитектуры проекта и методов доступных для вызова
9.13-----------------
Создание класса CustomMap.
По заверению автора сначала будем писать плохой код,
потом рефакторить
9.14-----------------
Создание методов CustomMap
9.15-----------------
Пояснил за дублирование когда
9.16-----------------
Рефакторинг. Использование типов для параметров функции.
Когда параметр не соответствуюет типу, то TS откидывает 
лишние свойства и оставляет только валидные
9.17-----------------
video not found. Использует интерфейс для параметров ф-ии addMap
9.18-----------------
Рефакторинг
9.19-----------------
Добавление модалки для маркеров
9.20 - 9.21----------
video not found
9.22-----------------
summary

***** 10_part(11) *****
10.1-----------------
Вступительное
10.2-----------------
Создание и конфигкрация tsconfig.json
tsc --init
tsc для запуска
tsc -w - наблюдатель
10.3-----------------
npm init -y
npm i nodemon concurrently
nodemon - запускает js файл при изменении
concurrently - запускает несколько команд npm
10.4-----------------
Объяснение Bubble sort
10.5-----------------
Создание класса sort
10.6-----------------
Реализация алгоритма для массива чисел
10.7-----------------
сотриторовать строку как массив не получится
Нужно другое
10.8-----------------
Если передавать и строку и массив как параметры ф-ии, то TS сузит
кол-во доступных методов и свойств. Только общие методы и свойства доступны
10.9-----------------
Решение: this.collection instanceof ClassConstructorORClassORInterface
Охрана типов крч
10.10----------------
10.11----------------
10.12----------------
Перенос логигки для сортировки массива чисел в отдельный класс

Больше видео нет. Плейлист не полный. Если куплю на Udemy, то продолжу.

Конец