***** 1_part *****
1.------------------
TS надстройка над js. В барзуер попадает js
2.------------------
npm i -g typescript ts-node
ts-node - its for starting compale ts to js in terminal
Настройка vscode и prettier расширения
3.------------------
npm i axios
npm init -y
4.------------------
tsc index.ts - скомпилировать в js ( tsc === typescript compiler )
node index.js - запус самого js file
Совмещает две это команды: ts-node index.ts
5.------------------
Намеренно совершили ошибку в деструктуризации response.data
6.------------------
В TS Interface используются для определения структуры объекта
Пример интерфейса: interface Todo {id: number; title: string; completed: boolean; }
Это поможет нам без ошибок деструктуризировать объект
7.------------------
Мы можем перепутать местами аргументы функции или передать не тот тип данных.
И когда передаются параметры функции, то указать к ним их типы:
function(id: number, title: string, completed: boolean){}

***** 2_part *****
2.1.-----------------
Объяснение структуры курса
2.2.-----------------
Тип - задает способ обращения к свойствам и функциям(методам),
которые есть у некоторого значения. Например:
'orange' - это строка. У нее тип String и поэтому мы можем обращаться
к методам и свойствам строк в JS
2.3------------------
Типы делят на 2 группы: {
    Примитивные: {
        string, number, void, symbol, null, boolean и т.д
    },
    Объектные
}
2.4, 2.5-------------
Применение типов

***** 3_part *****
3.1 - 3.5 -----------
Аннотация(указание) типов - это явное указание типа хранимых данных.
let index: number = 1;
Выведение типов - когда TS сам понимает, какой тип хранится в переменной.
Выведение работает только при указании значения в момент инициализации переменной.
let index = 5;
Если нужно указать несколько типов то:
let index: number | string = 5;
3.6------------------
Аннотация использовать когда тип ': any'. Получается когда TS не знает значение какого типа будет возвращаться.
И не может проверить на содержание проверок.

***** 4_part *****
4.1 - 4.2 -----------
К возвращаемому из функции значению можно применить выведение типов.
Но этого делать не стоит, а лучше строго прописывать.
Так же выведение никак не работает для параметров функции.
4.4------------------
void - пустой. Применять когда ничего не возвращается
4.5------------------
Деструктуризация по правилам TS
4.6------------------
Деструктуризация вложенных объектов доставляет мало удовольствия

***** 5_part *****
5.1------------------
Массивы в TS типизарованы. Состоят из одного типа данных, но всегда.
5.2------------------
Не получится добавить значение другого типа в массив.
Когда извлекается значения из массива и присваивается перемнной,
то TS сделает выведение типа.
5.3------------------
Чтобы добавлять разные типы данных в TS, то
нужно написать аннотоацию типов, если массив изначально пустой
или есть данные только одного типа, но в будущем будут и другие:
const itemsMass: (string | number)[] = [];
5.4------------------
В TS есть кортежи. Разобрано дальше.

***** 6_part *****
6.1------------------
Кортеж. Я понял смысл кортежа, но описать не могу. Пример:
cont tuple = ['brown', 13, true];
В Tuple(Кортеж) элементы расположены в строгом порядке.
6.2------------------
Tuple syntax:
const testTuple: [string, boolean, number, date] = ['123', true, 100, new Date()];
Alias for Tuple:
type Alias: [string, number];
const tupleAlias: Alias = ['text', 123]
6.3------------------
Tuple не дают понимание того, что означают элементы массива.
Редко применяются. Объект лучше.

***** 7_part *****
7.1------------------
Создает новый тип, описывая название свойств и типы значений объекта.
Тема очень важная
7.2------------------
Аннотации писать долго и код повторяется.
7.3------------------
7.4------------------
Используй Интефейс
7.5------------------
рефкторинг
7.6------------------
Интефейсы круты тем что их можно повторно использовать
7.7------------------
Входные параметры не соответствующие интерфейсу не попадут в функцию

***** 8_part *****
8.1 - 8.2 -----------
Тупо объяснения классов
8.3------------------
Есть три типа модификаторов.
public - каждый может вызывать.
private - вызов только внутри класса где объявлен.
protected - только внутри класса и внтури его наследников.
8.4------------------
8.5------------------
Если у ребенка нет Constructor, то он вызывает родительский.
Вызывать super() родителя.
8.6------------------
